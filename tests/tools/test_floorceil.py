import datetime as dt

import pandas as pd
import pytest
from pytz import AmbiguousTimeError

from portfolyo import tools

# TESTCASES_ALL_ON_BOUNDARY = [  # date, freq, periods, freqs
#     ("2020-01-01", "15min", 80, ("D", "MS", "QS", "YS")),
#     ("2020-01-01", "h", 20, ("D", "MS", "QS", "YS")),
#     ("2020-01-01", "D", 25, ("MS", "QS", "YS")),
#     ("2020-01-01", "MS", 3, ("QS", "YS")),
#     ("2020-01-01", "QS", 3, ("YS",)),
#     ("2020-04-01", "15min", 80, ("D", "MS", "QS")),
#     ("2020-04-01", "h", 20, ("D", "MS", "QS")),
#     ("2020-04-01", "D", 25, ("MS", "QS")),
#     ("2020-04-01", "MS", 3, ("QS",)),
#     ("2020-02-01", "15min", 80, ("D", "MS")),
#     ("2020-02-01", "h", 20, ("D", "MS")),
#     ("2020-02-01", "D", 25, ("MS",)),
#     ("2020-04-21", "15min", 80, ("D",)),
#     ("2020-04-21", "h", 20, ("D",)),
# ]

# TESTCASES_STAMPS_ONBOUNDARY = [  # date, freq
#     ("2020-01-01", "15min"),
#     ("2020-01-01", "h"),
#     ("2020-01-01", "D"),
#     ("2020-01-01", "MS"),
#     ("2020-01-01", "QS"),
#     ("2020-01-01", "YS"),
#     ("2020-04-01", "15min"),
#     ("2020-04-01", "h"),
#     ("2020-04-01", "D"),
#     ("2020-04-01", "MS"),
#     ("2020-04-01", "QS"),
#     ("2020-02-01", "15min"),
#     ("2020-02-01", "h"),
#     ("2020-02-01", "D"),
#     ("2020-02-01", "MS"),
#     ("2020-04-21", "15min"),
#     ("2020-04-21", "h"),
#     ("2020-04-21", "D"),
# ]

# TESTCASES_STAMPS_DATES = [  # date, fut, freq, floored, ceiled
#     ("2020-01-01", 0, "D", "2020-01-01", "2020-01-01"),
#     ("2020-01-01", 0, "MS", "2020-01-01", "2020-01-01"),
#     ("2020-01-01", 0, "QS", "2020-01-01", "2020-01-01"),
#     ("2020-01-01", 0, "YS", "2020-01-01", "2020-01-01"),
#     ("2020-01-01", 1, "D", "2020-01-02", "2020-01-02"),
#     ("2020-01-01", 1, "MS", "2020-02-01", "2020-02-01"),
#     ("2020-01-01", 1, "QS", "2020-04-01", "2020-04-01"),
#     ("2020-01-01", 1, "YS", "2021-01-01", "2021-01-01"),
#     ("2020-01-01", -1, "D", "2019-12-31", "2019-12-31"),
#     ("2020-01-01", -1, "MS", "2019-12-01", "2019-12-01"),
#     ("2020-01-01", -1, "QS", "2019-10-01", "2019-10-01"),
#     ("2020-01-01", -1, "YS", "2019-01-01", "2019-01-01"),
# ]
# TESTCASES_STAMPS_DATES = [  # ts, fut, freq, floored, ceiled
#     ("2020-12-31 12:00", 0, "D", "2020-12-31", "2021-01-01"),
#     ("2020-12-31 12:00", 0, "MS", "2020-12-01", "2021-01-01"),
#     ("2020-12-31 12:00", 0, "QS", "2020-10-01", "2021-01-01"),
#     ("2020-12-31 12:00", 0, "YS", "2020-01-01", "2021-01-01"),
#     ("2020-02-01", 0, "D", "2020-02-01", "2020-02-01"),
#     ("2020-02-01", 0, "MS", "2020-02-01", "2020-02-01"),
#     ("2020-02-01", 0, "QS", "2020-01-01", "2020-04-01"),
#     ("2020-02-01", 0, "YS", "2020", "2021"),
#     ("2020-01-01 23:55", 0, "D", "2020", "2020-01-02"),
#     ("2020-01-24 1:32", 0, "MS", "2020", "2020-02"),
#     ("2020-03-03 3:33", 0, "QS", "2020", "2020-04"),
#     ("2020-10-11 12:34", 0, "YS", "2020", "2021"),
#     ("2020-01-01 23:55", 1, "D", "2020-01-02", "2020-01-03"),
#     ("2020-01-24 1:32", 1, "MS", "2020-02", "2020-03"),
#     ("2020-03-03 3:33", 1, "QS", "2020-04", "2020-07"),
#     ("2020-10-11 12:34", 1, "YS", "2021", "2022"),
#     ("2020-01-01 23:55", -1, "D", "2019-12-31", "2020-01-01"),
#     ("2020-01-24 1:32", -1, "MS", "2019-12", "2020"),
#     ("2020-03-03 3:33", -1, "QS", "2019-10", "2020"),
#     ("2020-10-11 12:34", -1, "YS", "2019", "2020"),
#     ("2020-03-29 00:00", 0, "h", "2020-03-29 00:00", "2020-03-29 00:00"),
#     ("2020-10-25 00:00", 0, "h", "2020-10-25 00:00", "2020-10-25 00:00"),
# ]


# TESTCASES = [  # ts, freq, floored,
#     # First day of X and start of day.
#     ("2020-01-01", "15min", ["2020-01-01 00:15"),
#     ("2020-01-01", "h", "2020-01-01 01:00"),
#     ("2020-01-01", "D", "2020-01-02"),
#     ("2020-01-01", "MS", "2020-02-01"),
#     ("2020-01-01", "QS", "2020-04-01"),
#     ("2020-01-01", "YS", "2021-01-01"),
#     # First day of X but not start of day.
#     ("2020-01-01 06:00",0,  "15min", "2020-01-01 06:15"),
#     ("2020-01-01 06:00",0,  "h", "2020-01-01 07:00"),
#     ("2020-01-01 06:00",0,  "D", "2020-01-02 06:00"),
#     ("2020-01-01 06:00",0,  "MS", "2020-02-01 06:00"),
#     ("2020-01-01 06:00",0,  "QS", "2020-04-01 06:00"),
#     ("2020-01-01 06:00",0,  "YS", "2021-01-01 06:00"),
#     # Not first day of X but start of day.
#     ("2020-04-01",0,  "15min", "2020-04-01 00:15"),
#     ("2020-04-01",0,  "h", "2020-04-01 01:00"),
#     ("2020-04-01",0,  "D", "2020-04-02"),
#     ("2020-04-01",0,  "MS", "2020-05-01"),
#     ("2020-04-01",0,  "QS", "2020-07-01"),
#     ("2020-04-21",0,  "15min", "2020-04-21 00:15"),
#     ("2020-04-21",0,  "h", "2020-04-21 01:00"),
#     ("2020-04-21",0,  "D", "2020-04-22"),
#     # Not first day of X and not start of day.
#     ("2020-04-01 06:00", 0, "15min", "2020-04-01 06:15"),
#     ("2020-04-01 06:00", 0, "h", "2020-04-01 07:00"),
#     ("2020-04-01 06:00", 0, "D", "2020-04-02 06:00"),
#     ("2020-04-01 06:00", 0, "MS", "2020-05-01 06:00"),
#     ("2020-04-01 06:00", 0, "QS", "2020-07-01 06:00"),
#     ("2020-04-21 06:00", 0, "15min", "2020-04-21 06:15"),
#     ("2020-04-21 06:00", 0, "h", "2020-04-21 07:00"),
#     ("2020-04-21 06:00", 0, "D", "2020-04-22 06:00"),
# ]


# @pytest.mark.parametrize("start_time", ["00:00", "06:00"])
# @pytest.mark.parametrize("function", ["floor", "ceil"])
# @pytest.mark.parametrize("tz", [None, "Europe/Berlin", "Asia/Kolkata"])
# @pytest.mark.parametrize(("date", "freq"), TESTCASES_STAMPS_ONBOUNDARY)
# def test_floorceil_stamp_onboundary(
#     function: str, date: str, tz: str, freq: str, start_time: str
# ):
#     """Test flooring and ceiling if timestamp should not move."""
#     ts = f"{date} {start_time}"
#     start_of_day = None if start_time == "00:00" else dt.time(hour=6)
#     do_test_stamp(function, ts, tz, freq, 0, start_of_day, ts, ts)


# @pytest.mark.parametrize("start_time", ["00:00", "06:00"])
# @pytest.mark.parametrize("function", ["floor", "ceil"])
# @pytest.mark.parametrize("tz", [None, "Europe/Berlin", "Asia/Kolkata"])
# @pytest.mark.parametrize(
#     ("date", "fut", "freq", "floored", "ceiled"), TESTCASES_STAMPS_DATES
# )
# def test_floorceil_stamp_onboundary(
#     function: str,
#     date: str,
#     tz: str,
#     freq: str,
#     fut: int,
#     floored: str,
#     ceiled: str,
#     start_time: str,
# ):
#     """Test flooring and ceiling if timestamp should not move."""
#     ts, floored_ts, ceiled_ts = (
#         f"{date} {start_time}",
#         f"{floored} {start_time}",
#         f"{ceiled} {start_time}",
#     )
#     start_of_day = None if start_time == "00:00" else dt.time(hour=6)
#     do_test_stamp(function, ts, tz, freq, 0, start_of_day, floored_ts, ceiled_ts)


# def do_test_stamp(fn, ts, tz, freq, fut, start_of_day, floored, ceiled):
#     ts = pd.Timestamp(ts, tz=tz)
#     if fn == "floor":
#         result = tools.floor.stamp(ts, freq, fut, start_of_day)
#         expected = pd.Timestamp(floored, tz=tz)
#     else:
#         result = tools.ceil.stamp(ts, freq, fut, start_of_day)
#         expected = pd.Timestamp(ceiled, tz=tz)
#     assert result == expected


# def do_test_index(function, ts, i_freq, tz, freq, fut, floored, ceiled):
#     # Input.
#     first = pd.Timestamp(ts, tz=tz)
#     i = pd.date_range(first, freq=i_freq, periods=periods + 1)
#     # Output.
#     result = tools.isboundary.index(i, freq)
#     # Expected output.
#     expected_values = [False] * leading_zeros
#     if expected_repeat is None:
#         expected_values.extend([False] * (len(i) - len(expected_values)))
#     elif isinstance(expected_repeat, Iterable):
#         for er in expected_repeat:
#             expected_values.extend([True, *[False] * (er - 1)])
#         expected_values.extend([True, *[False] * (len(i) - len(expected_values) - 1)])
#     else:
#         expected_values.extend(
#             [num % expected_repeat == 0 for num in range(len(i) - len(expected_values))]
#         )
#     expected = pd.Series(expected_values, i, name="isboundary")
#     # Assert.
#     testing.assert_series_equal(result, expected)


TESTCASES = [  # ts, fut, freq, floored, ceiled
    ("2020-04-21 12:34:56", 0, "15min", "2020-04-21 12:30", "2020-04-21 12:45"),
    ("2020-04-21 12:34:56", 0, "h", "2020-04-21 12:00", "2020-04-21 13:00"),
    ("2020-04-21 12:34:56", 0, "D", "2020-04-21", "2020-04-22"),
    ("2020-04-21 12:34:56", 0, "MS", "2020-04-01", "2020-05-01"),
    ("2020-04-21 12:34:56", 0, "QS", "2020-04-01", "2020-07-01"),
    ("2020-04-21 12:34:56", 0, "YS", "2020-01-01", "2021-01-01"),
    ("2020-04-21 23:54:16", 0, "15min", "2020-04-21 23:45", "2020-04-22"),
    ("2020-04-21 23:54:16", 0, "h", "2020-04-21 23:00", "2020-04-22"),
    ("2020-04-21 23:54:16", 0, "D", "2020-04-21", "2020-04-22"),
    ("2020-04-21 23:54:16", 0, "MS", "2020-04-01", "2020-05-01"),
    ("2020-04-21 23:54:16", 0, "QS", "2020-04-01", "2020-07-01"),
    ("2020-04-21 23:54:16", 0, "YS", "2020-01-01", "2021-01-01"),
    ("2020", 0, "D", "2020", "2020"),
    ("2020", 0, "MS", "2020", "2020"),
    ("2020", 0, "QS", "2020", "2020"),
    ("2020", 0, "YS", "2020", "2020"),
    ("2020", 1, "D", "2020-01-02", "2020-01-02"),
    ("2020", 1, "MS", "2020-02", "2020-02"),
    ("2020", 1, "QS", "2020-04", "2020-04"),
    ("2020", 1, "YS", "2021", "2021"),
    ("2020", -1, "D", "2019-12-31", "2019-12-31"),
    ("2020", -1, "MS", "2019-12", "2019-12"),
    ("2020", -1, "QS", "2019-10", "2019-10"),
    ("2020", -1, "YS", "2019", "2019"),
    ("2020-12-31 12:00", 0, "D", "2020-12-31", "2021-01-01"),
    ("2020-12-31 12:00", 0, "MS", "2020-12-01", "2021-01-01"),
    ("2020-12-31 12:00", 0, "QS", "2020-10-01", "2021-01-01"),
    ("2020-12-31 12:00", 0, "YS", "2020-01-01", "2021-01-01"),
    ("2020-02-01", 0, "D", "2020-02-01", "2020-02-01"),
    ("2020-02-01", 0, "MS", "2020-02-01", "2020-02-01"),
    ("2020-02-01", 0, "QS", "2020-01-01", "2020-04-01"),
    ("2020-02-01", 0, "YS", "2020", "2021"),
    ("2020-01-01 23:55", 0, "D", "2020", "2020-01-02"),
    ("2020-01-24 1:32", 0, "MS", "2020", "2020-02"),
    ("2020-03-03 3:33", 0, "QS", "2020", "2020-04"),
    ("2020-10-11 12:34:56", 0, "YS", "2020", "2021"),
    ("2020-01-01 23:55", 1, "D", "2020-01-02", "2020-01-03"),
    ("2020-01-24 1:32", 1, "MS", "2020-02", "2020-03"),
    ("2020-03-03 3:33", 1, "QS", "2020-04", "2020-07"),
    ("2020-10-11 12:34:56", 1, "YS", "2021", "2022"),
    ("2020-01-01 23:55", -1, "D", "2019-12-31", "2020-01-01"),
    ("2020-01-24 1:32", -1, "MS", "2019-12", "2020"),
    ("2020-03-03 3:33", -1, "QS", "2019-10", "2020"),
    ("2020-10-11 12:34:56", -1, "YS", "2019", "2020"),
    ("2020-03-29 00:00", 0, "h", "2020-03-29 00:00", "2020-03-29 00:00"),
    ("2020-10-25 00:00", 0, "h", "2020-10-25 00:00", "2020-10-25 00:00"),
]

TESTCASES_DST = [  # ts, tz, freq, floored, ceiled
    ("2020-04-21 15:25", None, "h", "2020-04-21 15:00", "2020-04-21 16:00"),
    ("2020-04-21 15:25", "Europe/Berlin", "h", "2020-04-21 15:00", "2020-04-21 16:00"),
    (
        "2020-04-21 15:25+0200",
        "Europe/Berlin",
        "h",
        "2020-04-21 15:00+0200",
        "2020-04-21 16:00+0200",
    ),
    ("2020-04-21 15:25", "Asia/Kolkata", "h", "2020-04-21 15:00", "2020-04-21 16:00"),
    ("2020-03-29 01:50", None, "15min", "2020-03-29 01:45", "2020-03-29 02:00"),
    ("2020-03-29 03:05", None, "15min", "2020-03-29 03:00", "2020-03-29 03:15"),
    (
        "2020-03-29 01:50+0100",
        "Europe/Berlin",
        "15min",
        "2020-03-29 01:45+0100",
        "2020-03-29 03:00+0200",
    ),
    (
        "2020-03-29 03:05+0200",
        "Europe/Berlin",
        "15min",
        "2020-03-29 03:00+0200",
        "2020-03-29 03:15+0200",
    ),
    (
        "2020-03-29 01:50",
        "Europe/Berlin",
        "15min",
        "2020-03-29 01:45",
        "2020-03-29 03:00",
    ),
    ("2020-03-29 03:05", None, "15min", "2020-03-29 03:00", "2020-03-29 03:15"),
    ("2020-10-25 02:50", None, "15min", "2020-10-25 02:45", "2020-10-25 03:00"),
    ("2020-10-25 02:05", None, "15min", "2020-10-25 02:00", "2020-10-25 02:15"),
    (
        "2020-10-25 02:50+0200",
        "Europe/Berlin",
        "15min",
        "2020-10-25 02:45+0200",
        "2020-10-25 02:00+0100",
    ),
    (
        "2020-10-25 02:05+0200",
        "Europe/Berlin",
        "15min",
        "2020-10-25 02:00+0200",
        "2020-10-25 02:15+0200",
    ),
    (
        "2020-10-25 02:50+0100",
        "Europe/Berlin",
        "15min",
        "2020-10-25 02:45+0100",
        "2020-10-25 03:00+0100",
    ),
    (
        "2020-10-25 02:05+0100",
        "Europe/Berlin",
        "15min",
        "2020-10-25 02:00+0100",
        "2020-10-25 02:15+0100",
    ),
    (
        "2020-10-25 02:30+0200",
        "Europe/Berlin",
        "h",
        "2020-10-25 02:00+0200",
        "2020-10-25 02:00+0100",
    ),
    (
        "2020-10-25 02:30+0100",
        "Europe/Berlin",
        "h",
        "2020-10-25 02:00+0100",
        "2020-10-25 03:00+0100",
    ),
]

TESTCASES_NONNATURAL = [  # ts, freq, offset_hours, floored, ceiled
    ("2020-01-01 00:00", "15min", 6, "2020-01-01 00:00", "2020-01-01 00:00"),
    ("2020-01-01 00:00", "h", 6, "2020-01-01 00:00", "2020-01-01 00:00"),
    ("2020-01-01 00:00", "D", 6, "2019-12-31 06:00", "2020-01-01 06:00"),
    ("2020-01-01 00:00", "MS", 6, "2019-12-01 06:00", "2020-01-01 06:00"),
    ("2020-01-01 00:00", "QS", 6, "2019-10-01 06:00", "2020-01-01 06:00"),
    ("2020-01-01 00:00", "YS", 6, "2019-01-01 06:00", "2020-01-01 06:00"),
    ("2020-01-01 04:00", "15min", 6, "2020-01-01 04:00", "2020-01-01 04:00"),
    ("2020-01-01 04:00", "h", 6, "2020-01-01 04:00", "2020-01-01 04:00"),
    ("2020-01-01 04:00", "D", 6, "2019-12-31 06:00", "2020-01-01 06:00"),
    ("2020-01-01 04:00", "MS", 6, "2019-12-01 06:00", "2020-01-01 06:00"),
    ("2020-01-01 04:00", "QS", 6, "2019-10-01 06:00", "2020-01-01 06:00"),
    ("2020-01-01 04:00", "YS", 6, "2019-01-01 06:00", "2020-01-01 06:00"),
    ("2019-12-31 12:00", "15min", 6, "2019-12-31 12:00", "2019-12-31 12:00"),
    ("2019-12-31 12:00", "h", 6, "2019-12-31 12:00", "2019-12-31 12:00"),
    ("2019-12-31 12:00", "D", 6, "2019-12-31 06:00", "2020-01-01 06:00"),
    ("2019-12-31 12:00", "MS", 6, "2019-12-01 06:00", "2020-01-01 06:00"),
    ("2019-12-31 12:00", "QS", 6, "2019-10-01 06:00", "2020-01-01 06:00"),
    ("2019-12-31 12:00", "YS", 6, "2019-01-01 06:00", "2020-01-01 06:00"),
    ("2020-04-21 15:25", "15min", 6, "2020-04-21 15:15", "2020-04-21 15:30"),
    ("2020-04-21 15:25", "h", 6, "2020-04-21 15:00", "2020-04-21 16:00"),
    ("2020-03-29 01:40", "15min", 6, "2020-03-29 01:30", "2020-03-29 01:45"),
    ("2020-03-29 03:05", "15min", 6, "2020-03-29 03:00", "2020-03-29 03:15"),
    ("2020-04-21 15:25", "D", 6, "2020-04-21 06:00", "2020-04-22 06:00"),
    ("2020-03-28 01:40", "D", 6, "2020-03-27 06:00", "2020-03-28 06:00"),
    ("2020-03-29 01:40", "D", 6, "2020-03-28 06:00", "2020-03-29 06:00"),
    ("2020-03-30 01:40", "D", 6, "2020-03-29 06:00", "2020-03-30 06:00"),
    ("2020-03-28 03:40", "D", 6, "2020-03-27 06:00", "2020-03-28 06:00"),
    ("2020-03-29 03:40", "D", 6, "2020-03-28 06:00", "2020-03-29 06:00"),
    ("2020-03-30 03:40", "D", 6, "2020-03-29 06:00", "2020-03-30 06:00"),
    ("2020-10-24 01:40", "D", 6, "2020-10-23 06:00", "2020-10-24 06:00"),
    ("2020-10-25 01:40", "D", 6, "2020-10-24 06:00", "2020-10-25 06:00"),
    ("2020-10-26 01:40", "D", 6, "2020-10-25 06:00", "2020-10-26 06:00"),
    ("2020-10-24 03:40", "D", 6, "2020-10-23 06:00", "2020-10-24 06:00"),
    ("2020-10-25 03:40", "D", 6, "2020-10-24 06:00", "2020-10-25 06:00"),
    ("2020-10-26 03:40", "D", 6, "2020-10-25 06:00", "2020-10-26 06:00"),
    ("2020-04-01 05:25", "MS", 6, "2020-03-01 06:00", "2020-04-01 06:00"),
    ("2020-04-21 15:25", "MS", 6, "2020-04-01 06:00", "2020-05-01 06:00"),
    ("2020-03-28 01:40", "MS", 6, "2020-03-01 06:00", "2020-04-01 06:00"),
    ("2020-03-29 01:40", "MS", 6, "2020-03-01 06:00", "2020-04-01 06:00"),
    ("2020-03-30 01:40", "MS", 6, "2020-03-01 06:00", "2020-04-01 06:00"),
    ("2020-10-24 01:40", "MS", 6, "2020-10-01 06:00", "2020-11-01 06:00"),
    ("2020-10-25 01:40", "MS", 6, "2020-10-01 06:00", "2020-11-01 06:00"),
    ("2020-10-26 01:40", "MS", 6, "2020-10-01 06:00", "2020-11-01 06:00"),
    ("2020-04-01 05:25", "QS", 6, "2020-01-01 06:00", "2020-04-01 06:00"),
    ("2020-04-21 15:25", "QS", 6, "2020-04-01 06:00", "2020-07-01 06:00"),
    ("2020-03-28 01:40", "QS", 6, "2020-01-01 06:00", "2020-04-01 06:00"),
    ("2020-03-29 01:40", "QS", 6, "2020-01-01 06:00", "2020-04-01 06:00"),
    ("2020-03-30 01:40", "QS", 6, "2020-01-01 06:00", "2020-04-01 06:00"),
    ("2020-10-24 01:40", "QS", 6, "2020-10-01 06:00", "2021-01-01 06:00"),
    ("2020-10-25 01:40", "QS", 6, "2020-10-01 06:00", "2021-01-01 06:00"),
    ("2020-10-26 01:40", "QS", 6, "2020-10-01 06:00", "2021-01-01 06:00"),
]

# TESTCASES_NONNATURAL_INDEX = [  # ts, i_freq, freq, floored, ceiled
#     ("2020-01-01 00:00", "15min", 6, "2020-01-01 00:00", "2020-01-01 00:00"),
#     ("2020-01-01 00:00", "h", 6, "2020-01-01 00:00", "2020-01-01 00:00"),
#     ("2020-01-01 00:00", "D", 6, "2019-12-31 06:00", "2020-01-01 06:00"),
#     ("2020-01-01 00:00", "MS", 6, "2019-12-01 06:00", "2020-01-01 06:00"),
#     ("2020-01-01 00:00", "QS", 6, "2019-10-01 06:00", "2020-01-01 06:00"),
#     ("2020-01-01 00:00", "YS", 6, "2019-01-01 06:00", "2020-01-01 06:00"),
#     ("2020-01-01 04:00", "15min", 6, "2020-01-01 04:00", "2020-01-01 04:00"),
#     ("2020-01-01 04:00", "h", 6, "2020-01-01 04:00", "2020-01-01 04:00"),
#     ("2020-01-01 04:00", "D", 6, "2019-12-31 06:00", "2020-01-01 06:00"),
#     ("2020-01-01 04:00", "MS", 6, "2019-12-01 06:00", "2020-01-01 06:00"),
#     ("2020-01-01 04:00", "QS", 6, "2019-10-01 06:00", "2020-01-01 06:00"),
#     ("2020-01-01 04:00", "YS", 6, "2019-01-01 06:00", "2020-01-01 06:00"),
#     ("2019-12-31 12:00", "15min", 6, "2019-12-31 12:00", "2019-12-31 12:00"),
#     ("2019-12-31 12:00", "h", 6, "2019-12-31 12:00", "2019-12-31 12:00"),
#     ("2019-12-31 12:00", "D", 6, "2019-12-31 06:00", "2020-01-01 06:00"),
#     ("2019-12-31 12:00", "MS", 6, "2019-12-01 06:00", "2020-01-01 06:00"),
#     ("2019-12-31 12:00", "QS", 6, "2019-10-01 06:00", "2020-01-01 06:00"),
#     ("2019-12-31 12:00", "YS", 6, "2019-01-01 06:00", "2020-01-01 06:00"),
#     ("2020-04-21 15:25", "15min", 6, "2020-04-21 15:15", "2020-04-21 15:30"),
#     ("2020-04-21 15:25", "h", 6, "2020-04-21 15:00", "2020-04-21 16:00"),
#     ("2020-03-29 01:40", "15min", 6, "2020-03-29 01:30", "2020-03-29 01:45"),
#     ("2020-03-29 03:05", "15min", 6, "2020-03-29 03:00", "2020-03-29 03:15"),
#     ("2020-04-21 15:25", "D", 6, "2020-04-21 06:00", "2020-04-22 06:00"),
#     ("2020-03-28 01:40", "D", 6, "2020-03-27 06:00", "2020-03-28 06:00"),
#     ("2020-03-29 01:40", "D", 6, "2020-03-28 06:00", "2020-03-29 06:00"),
#     ("2020-03-30 01:40", "D", 6, "2020-03-29 06:00", "2020-03-30 06:00"),
#     ("2020-03-28 03:40", "D", 6, "2020-03-27 06:00", "2020-03-28 06:00"),
#     ("2020-03-29 03:40", "D", 6, "2020-03-28 06:00", "2020-03-29 06:00"),
#     ("2020-03-30 03:40", "D", 6, "2020-03-29 06:00", "2020-03-30 06:00"),
#     ("2020-10-24 01:40", "D", 6, "2020-10-23 06:00", "2020-10-24 06:00"),
#     ("2020-10-25 01:40", "D", 6, "2020-10-24 06:00", "2020-10-25 06:00"),
#     ("2020-10-26 01:40", "D", 6, "2020-10-25 06:00", "2020-10-26 06:00"),
#     ("2020-10-24 03:40", "D", 6, "2020-10-23 06:00", "2020-10-24 06:00"),
#     ("2020-10-25 03:40", "D", 6, "2020-10-24 06:00", "2020-10-25 06:00"),
#     ("2020-10-26 03:40", "D", 6, "2020-10-25 06:00", "2020-10-26 06:00"),
#     ("2020-04-01 05:25", "MS", 6, "2020-03-01 06:00", "2020-04-01 06:00"),
#     ("2020-04-21 15:25", "MS", 6, "2020-04-01 06:00", "2020-05-01 06:00"),
#     ("2020-03-28 01:40", "MS", 6, "2020-03-01 06:00", "2020-04-01 06:00"),
#     ("2020-03-29 01:40", "MS", 6, "2020-03-01 06:00", "2020-04-01 06:00"),
#     ("2020-03-30 01:40", "MS", 6, "2020-03-01 06:00", "2020-04-01 06:00"),
#     ("2020-10-24 01:40", "MS", 6, "2020-10-01 06:00", "2020-11-01 06:00"),
#     ("2020-10-25 01:40", "MS", 6, "2020-10-01 06:00", "2020-11-01 06:00"),
#     ("2020-10-26 01:40", "MS", 6, "2020-10-01 06:00", "2020-11-01 06:00"),
#     ("2020-04-01 05:25", "QS", 6, "2020-01-01 06:00", "2020-04-01 06:00"),
#     ("2020-04-21 15:25", "QS", 6, "2020-04-01 06:00", "2020-07-01 06:00"),
#     ("2020-03-28 01:40", "QS", 6, "2020-01-01 06:00", "2020-04-01 06:00"),
#     ("2020-03-29 01:40", "QS", 6, "2020-01-01 06:00", "2020-04-01 06:00"),
#     ("2020-03-30 01:40", "QS", 6, "2020-01-01 06:00", "2020-04-01 06:00"),
#     ("2020-10-24 01:40", "QS", 6, "2020-10-01 06:00", "2021-01-01 06:00"),
#     ("2020-10-25 01:40", "QS", 6, "2020-10-01 06:00", "2021-01-01 06:00"),
#     ("2020-10-26 01:40", "QS", 6, "2020-10-01 06:00", "2021-01-01 06:00"),
# ]


@pytest.mark.parametrize("function", ["floor", "ceil"])
@pytest.mark.parametrize("tz", [None, "Europe/Berlin", "Asia/Kolkata"])
@pytest.mark.parametrize(("ts", "fut", "freq", "floored", "ceiled"), TESTCASES)
def test_floorceil(
    function: str,
    ts: str,
    tz: str,
    fut: int,
    freq: str,
    floored: str,
    ceiled: str,
):
    """Test flooring and ceiling without dst-transition."""
    do_test_stamp(function, ts, freq, fut, 0, tz, floored, ceiled)


@pytest.mark.parametrize("function", ["floor", "ceil"])
@pytest.mark.parametrize(("ts", "tz", "freq", "floored", "ceiled"), TESTCASES_DST)
def test_floorceil_dst(
    function: str,
    ts: str,
    tz: str,
    freq: str,
    floored: str,
    ceiled: str,
):
    """Test flooring and ceiling with dst-transition."""
    if ts in ("2020-10-25 02:30+0200", "2020-10-25 02:50+0200") and function == "ceil":
        pytest.skip(
            "Error caused by pandas not correctly handling edge case. Not our fault."
        )
    try:
        do_test_stamp(function, ts, freq, 0, 0, tz, floored, ceiled)
    except AmbiguousTimeError:
        pytest.skip(
            "Pandas can't floor/ceil, even though all information is there. Not our fault."
        )


@pytest.mark.parametrize("function", ["floor", "ceil"])
@pytest.mark.parametrize("tz", [None, "Europe/Berlin", "Asia/Kolkata"])
@pytest.mark.parametrize(
    ("ts", "freq", "offset_hours", "floored", "ceiled"), TESTCASES_NONNATURAL
)
def test_floorceil_nonnatural(
    function: str,
    ts: str,
    tz: str,
    freq: str,
    offset_hours: int,
    floored: str,
    ceiled: str,
):
    """Test flooring and ceiling with nonnatural day start (and dst-transition)."""
    do_test_stamp(function, ts, freq, 0, offset_hours, tz, floored, ceiled)


# def do_test_general(
#     stamporindex, function, ts, freq, fut, offset_hours, tz, floored, ceiled
# ):
#     try:
#         if stamporindex == "stamp" and function == "floor":
#             do_test_stamp(tools.floor.stamp, ts, freq, fut, offset_hours, tz, floored)
#         elif stamporindex == "stamp" and function == "ceil":
#             do_test_stamp(tools.ceil.stamp, ts, freq, fut, offset_hours, tz, ceiled)
#         elif stamporindex == "index" and function == "floor":
#             do_test_index(tools.floor.index, ts, freq, fut, offset_hours, tz, floored)
#         elif stamporindex == "index" and function == "ceil":
#             do_test_index(tools.ceil.index, ts, freq, fut, offset_hours, tz, ceiled)
#         else:
#             raise ValueError("Unknown testcase.")
#     # Ceatch errors caused by pandas handling of dst and not by our code.
#     except (AmbiguousTimeError, NonExistentTimeError):
#         pytest.skip(
#             "Error caused by pandas not correctly handling edge case. Not our fault."
#         )
#     except ValueError as e:
#         if "Cannot infer" in e.args[0]:
#             pytest.skip(
#                 "Error caused by pandas not correctly handling edge case. Not our fault."
#             )


def do_test_stamp(function, ts, freq, fut, offset_hours, tz, floored, ceiled):
    if function == "floor":
        fn, expected = tools.floor.stamp, floored
    else:
        fn, expected = tools.ceil.stamp, ceiled
    ts = pd.Timestamp(ts, tz=tz)
    start_of_day = dt.time(hour=offset_hours)
    result = fn(ts, freq, fut, start_of_day)
    expected = pd.Timestamp(expected, tz=tz)
    assert result == expected


# def do_test_stamp(fn, ts, freq, fut, offset_hours, tz, expected):
#     ts = pd.Timestamp(ts, tz=tz)
#     expected = pd.Timestamp(expected, tz=tz)
#     start_of_day = dt.time(hour=offset_hours)
#     result = fn(ts, freq, fut, start_of_day)
#     assert result == expected


# def do_test_index(fn, ts, freq, fut, offset_hours, tz, expected):
#     ts = pd.Timestamp(ts, tz=tz)
#     i = pd.date_range(ts, periods=10, freq=freq)  # causes rounding
#     i += ts - i[0]  # undoes the rounding
#     result = fn(i, freq, fut)
#     result.freq = None  # disregard checking frequencies here
#     expected = pd.date_range(pd.Timestamp(expected, tz=tz), periods=10, freq=freq)
#     expected.freq = None  # disregard checking frequencies here
#     testing.assert_index_equal(result, expected)
